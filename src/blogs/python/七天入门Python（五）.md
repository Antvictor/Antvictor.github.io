---
# 这是文章的标题
title: 七天入门Python（五）之集合、字典、列表及元组
# 这是页面的图标
icon: 
# 这是侧边栏的顺序
order: 5
# 设置作者
author: Antvictor
# 设置写作时间
date: 2023-08-21
# 一个页面可以有多个分类
category:
  - 语言
# 一个页面可以有多个标签
tag: 
  - Python
# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在文章收藏中
# star: true

# 你可以自定义页脚
# footer: 这是测试显示的页脚

# 你可以自定义版权信息
# copyright: 
# 定义上一篇
prev: 七天入门Python（四）.md
# 下一篇
next:
---
大家好，我是Antvictor，励志要成为一名架构师的程序员。

在上一篇我们学习了运算符、逻辑运算符及条件判断。现在我们来学习一下列表、集合、字典及元组。

无论是列表、集合还是其他，他们只是不同的存储方式，但这些概念可以说是所有开发语言都有的，而且都比较重要，因为他们是程序中最主要的数据存储方式。
# 列表
序列是`Python`中最基本的数据结构，序列会为每元素分配一个数字--它的位置，也叫索引。第一个的索引为0，第二个的为1，以此类推，绝大多数语言的数据结构都是从0开始数的。

而列表便是`Python`序列的一个类型

在`Python`中列表不会对数据类型有要求。

创建一个列表只需要用`[]`包裹起来，用","分割不同的数据，如下：
```python
a = [1,2,"test",0.5]
b = [1,2,3,4,5]
c = ["test", 'hello', 'world']
```

## 查询

查询列表的值，需要使用索引来查询指定位置：

```python
print(a[0]) # 1
print(a[1]) # 2
```

同时在`python`中有一些特殊的索引: 负的值，使用`-x`时，返回的便是列表倒数第x位的值, 以此类推：

```python
print(a[-1]) # 返回倒数第一个：0.5
print(a[-2]) # 返回倒数第二个：test
```

上述方法，在不知道列表多长或需要返回后面几位的时候很好用，当然如果能知道列表的长度就更好了，那么有什么方法吗？ 有，使用`len(列表)`可以直接查看列表的长度。

```python
print(len(a)) # 4
```

## 添加、删除及修改列表中的元素

### 添加
将数据添加到队尾：

```python
a.append("hello")
print(a) # [1,2,'test',0.5, 'hello']
```

将数据添加到指定的位置, 位置要使用索引：

```python
a.insert(2, "world")
print(a) # [1, 2, 'world', 'test', 0.5, 'hello']
```

### 删除

使用`del`删除指定位置的元素：

```python
del a[3]
print(a) # [1, 2, 'world', 0.5, 'hello']
```

使用`pop`查询指定位置的元素并删除，也叫推出：

```python
print(a.pop()) # 推出最后一个位置上的值 hello
print(a.pop(2)) # 推出指定位置的值 world
```

使用`remove`根据值来进行删除, 如果有多个相同的值，需要多次删除：

为了方便测试，我们向列表`a`中再加一些相同的数据：

```python
a.insert(2,"test")
a.append("test")
print(a) #[1, 2, 'test', 0.5, 'test']
```

现在我们开始删除：

```python
a.remove("test")
print(a) # [1, 2, 0.5, 'test']
a.remove("test")
print(a) # [1, 2, 0.5]
```

# 元组
元组是什么呢？

元组是一个不可以变的列表，也就是说元组在创建后就不能再新增、删除、修改了。

元组使用`()`进行创建，代码如下：
```python
tuple = (1,2,"2",0.2)
print(tuple)
print(tuple[2])
del tuple[2] # 报错
```

元组拥有和列表相同的特性，可以通过索引进行查询，可以存储不限类型的元素，唯独不可变。所以也就没有了新增、查询、删除等。

# 字典

什么是字典呢？

字典是一种`key:value`的数据结构，存储的是一个**键值对**。

那么怎么使用呢？

字典使用`{"key":value}的形式来创建
```python
maps = {'name':"Ant", 'age':25, 2:3}
print(maps) 
```

## 查询
查询的方式和列表的相同，也是使用`变量名[]`，不过区别在于，字典查询时传的不再是索引，而是`key`。

```python
print(maps[name]) # Ant
print(maps[2]) # 3
print(maps[3]) # 报错
```

如代码中所示，查询没有的key时会报错，那么怎么避免呢？

使用`get('key', msg)`方法, 如果查询不到，则会返回msg。

```python
print(maps.get(3, 4)) # 4
```

## 新增
使用`变量名[key] = value`的方式新增，需要注意的是：如果key已经在字典中了，那么使用这种方式就变成了修改，key是不能重复存在

```python
maps['new'] = 'hello' 
print(maps) # {'name': 'Ant', 'age': 25, 2: 3, 'new': 'hello'}

maps[2] = 4
print(maps) # {'name': 'Ant', 'age': 25, 2: 4, 'new': 'hello'}
```
## 修改
修改如上所述，对已有的key进行重新赋值，便完成了修改。
## 删除
删除和列表一致，使用`del`进行删除，不再赘述。

# 集合
集合（Set）是一种列表形式的字典，使用的是字典的key的规则，即：不能重复。

Set也使用`{}`,只是不再是键值对，而是和列表一样用`,`分割，并且Set是无序的，所以不能通过索引查询：

```python
sets = {"1","sss",2,3,0.5}
print(sets) # {0.5, 2, 3, 'sss', '1'}
```

## 新增

使用`add()`或`update()`可以进行新元素的添加，需要注意的是`update`不能传入数字, 而且会将字符串拆分，`update`还可以传入列表、元组、字典。
如果新增的内容是Set中已经有的，那么不会添加。

```python
sets.add("1") 
print(sets) # {0.5, 2, 3, 'sss', '1'} 无新增

sets.add(22)
print(sets) # {0.5, 2, 3, 22, 'sss', '1'}

sets.add("123")
print(sets) # {0.5, 2, 3, 22, '123', 'sss', '1'}

sets.update("123")
print(sets) # {0.5, 2, 3, 'sss', 22, '1', '3', '123', '2'}

maps1 = {"test":"sets"}
sets.update(maps1)
print(sets) # {0.5, 2, 3, '3', 22, '1', 'sss', '123', 'test', '2'}
```

`update`传入字典的话，只会记录`key`。

## 删除
使用集合时，是不能像列表那样通过索引或像字典一样通过key来查询的，使用集合只能通过将集合中的元素清除的方式获取，而清除的前提是知道了`set`中有什么值，所以`set`一般用来确认值是否在`set`中的。

那么我们可以通过哪些方法呢？

可以通过`remove`、`pop`、`discard`方法进行删除，需要注意：`remove`删除没有的值时会报错，而`discard`则不会。

```python
sets.remove("test")
print(sets)  # {0.5, 2, 3, '2', '3', 22, 'sss', '1', '123'}
print(sets.pop()) # 0.5
sets.discard("test")
print(sets) # {2, 3, '2', '3', 22, 'sss', '1', '123'}
sets.remove("test") # 报错
```

哦，用了全篇的`del`首次失去了宠爱，他无效了，真的如此吗？ 其实`del`虽然不能删除元素了，但它可以掀桌子，直接删掉集合。
```python
del sets
print(sets) # 报错
```

# 结语
本篇我们了解了`Python`中存储数据的结构：列表、元组、字典及集合，那么存起来不用怎么能行呢，那么将列表中存的数据全部获取呢？总不能一个个索引查询吧，那也太麻烦了。

下一篇我们便讲一下，什么是循环。看循环是如何将列表中的数据取出。

如果有表达有误的地方，欢迎评论区讨论，我会及时回复并修改有误的内容，感谢观看